% Alla i gruppen ska lämna in individuellt i Moodle. 
% Det ska dock vara samma fil för alla så att vi kan se vilka som har jobbat ihop.
\documentclass[a4paper,10pt,oneside,onecolumn]{article}

\usepackage[swedish]{babel}

% Får ni problem med att pdf-filen ser suddig ut på skärmen så beror det på att ni inte har 
% en fullständig fontuppsättning och att bitmappade fonter i fel skala används. Den bästa lösningen 
% är att uppdatera fontuppsättningen, men man kan också plocka bort denna rad. Avstavning fungerar 
% dock betydligt sämre då.
\usepackage[T1]{fontenc}

\usepackage[latin1]{inputenc}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{url}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{color}
\usepackage{hyperref}
\hypersetup{linktocpage}
\usepackage{xspace,graphicx}

\definecolor{javared}{rgb}{0.6,0,0} % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{javapurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc

\lstset{language=Java,
basicstyle=\ttfamily,
keywordstyle=\color{javapurple}\bfseries,
stringstyle=\color{javared},
commentstyle=\color{javagreen},
morecomment=[s][\color{javadocblue}]{/**}{*/},
numbers=left,
numberstyle=\small\color{black},
stepnumber=1,
numbersep=10pt,
tabsize=2,
showspaces=false,
showstringspaces=false,
breaklines=true}

% Glöm inte att uppdatera rubriken
\title{ALDA VT12: Algoritmdesigntekniker}

\author{Leon Hennings\\leonh \and Kamyar Sajjadi\\kamy-saj}

\begin{document}

\maketitle
\tableofcontents

\section{Closest-Point Problem}
\subsection{Beskrivning}
Vi har denna vecka valt att implementera en Divide and Conquer algoritm. Algoritmen vi valt är en algroritm 
som ska hitta de punkter som ligger närmast varandra. Problemet nämns i boken på sida 406, Closest-Points Problem. 
Vi valde att metoden ska returnera det lägsta avståndet. Problemet går att lösa genom att jämföra alla punkter 
mot varandra, detta genom att implementera en Brute Force metod som har tidskomplexitet O($N^{2}$). Det går även att 
lösa problemet genom Divide and Conquer vilket då istället ger tidskomplexiteten O(n log n). 
Vi har valt att skriva en klass som har en ArrayList med java.awt.Point:s som element. 
Listan sorteras först med hänsyn till punkternas x värde.
Algoritmen bestämmer en linje som delar listan på mitten i två logiska partitioner, en vänsterpartition och en 
högerpartition. Sedan kallas algoritmen rekursivt på de två partitionerna.
Basecaset för den rekursiva algoritmen är att varje partition ska bestå av mindre än 3 element. När algoritmen 
nått basecaset så kommer partitionen att sökas igenom och det kortaste avståndet mellan de närmaste punkterna 
kommer returneras. Det lägsta av dessa sätts till smallest.
Nu när vi går ur rekursionen så kollar algoritmen om det finns några punkter som ligger på kortare avstånd än 
smallest från den delande linjen. Dessa punkter läggs till en ny lista och denna sorteras med hänsyn till 
punkternas y värde. Arean består av de element som ligger inom intervallet (mittpunkten-minsta < punktens X < mittpunkten+minsta).
Då punkterna är sorterade på y kan vi ignorera de fallen då differensen mellan punkternas y värde är större än smallest.
Sedan kontrollerar vi om något par av punkter i denna area har kortare avstånd till varandra. Om detta värde är 
mindre än smallest sätts det till smallest som slutligen returneras.
\newpage

\subsection{Kod}
\begin{lstlisting}
/**
 * Klassen för Closest-Pair problem.
 * @author Leon Hennings
 * @author Kamyar Sajjadi
 */
public class ClosestPair{

	// ArrayList för samtliga punkter
	private ArrayList<Point> plane = new ArrayList<Point>();

	/**
	 * Comperator för att jämföra i X-led
	 */
	private class CmpX implements Comparator<Point>{
		public int compare(Point p1, Point p2){
			if(p1.x==p2.x)
				return p1.y-p2.y;
			else
				return p1.x-p2.x;
		}
	}

	/**
	 * Comparator för att jämföra i Y-led
	 */
	private class CmpY implements Comparator<Point>{
		public int compare(Point p1, Point p2){
			if(p1.y==p2.y)
				return p1.x-p2.x;
			else
				return p1.y-p2.y;
		}
	}

	/**
	 * Metod för att lägga till punkter i arrayen
	 * @param p Som är en Point som ska läggas till i plane
	 */
	public void addPoint(Point p){
		plane.add(p);
	}

	/**
	 * toString för att få en bra överblick över listan.
	 * Denna metod är mest användbar när man ska debugga.
	 * @return str
	 */
	public String toString(){
		String str= "";
		for(Point p : plane){
			str+= "(" + p.x + p.y+ ")" + "\n";
		}
		return str;
	}

	/**
	 * Metod för att få storleken av listan. 
	 * @return the size of the array
	 */
	public int getPlaneSize(){
		return plane.size();
	}

	/**
	 * Räknar ut avståndet mellan två punkter.
	 * @param p1 En av punkterna
	 * @param p2 den andra punkten
	 * @return en double med avståndet från punkt p1 och punkt p2
	 */
	private double getDistance(Point p1, Point p2){
		return Math.sqrt( Math.pow((p1.getX()-p2.getX()), 2.0) + Math.pow((p1.getY()-p2.getY()), 2.0) );
	}

	/**
	 * Den publika metoden för att hitta de kortaste avståndet. 
	 * denna metod kommer att sortera listan i X-led och sedan 
	 * anropa den privata findClosestPair.
	 */
	public double findClosestPair(){
		Collections.sort(plane, new CmpX());
		return findClosestPair(0, plane.size()-1);
	}

	/**
	 * Den privata metoden för att hitta det korstaste avståndet. 
	 * @param intervalStart 
	 * @param instervalEnd
	 * @return smallest Kortaste avståndet. 
	 */
	private double findClosestPair(int intervalStart, int intervalEnd){
		// Basecase som vi når när listan har mindre än 3 element i sig. 
		if(intervalEnd-intervalStart<=2){ 
			return findClosestInInterval(intervalStart, intervalEnd);
		} 
		// Här kommer uppdelningen av listorna att ske. Vardera sida
		// av listan kommer att anropas med findClosestPair. 
		else
		{
			// Detta är mitten av den lista som vi arbetar på just nu. 
			int middle = ((intervalStart+intervalEnd)/2);
			// Detta är mitten fast i X-led.
			double middleX = (plane.get(intervalStart).getX()+plane.get(intervalEnd).getX())/2;
			// De rekursiva anropen. 
			double left = findClosestPair(intervalStart, middle);
			double right = findClosestPair(middle+1, intervalEnd); 
			// Sätter smallest till det minsta av left och right
			double smallest = (left < right ? left : right);

			// Här går vi igenom elementen för att hitta de element som ska ligga i 
			// mittenArean (strip). Dessa ska ligga i intervallet som vi har nämnt i beskrivningen. 
			// Sedan sorteras denna lista i Y-led.
			ArrayList<Point> strip = new ArrayList<Point>();

			for(Point p : plane)
				if(p.getX() > (middleX - smallest) && p.getX() < (middleX + smallest))
					strip.add(p);

			Collections.sort(strip, new CmpY());

			// En BruteForce metod för att kontrollera de element som vi lagt in 
			// i strip. Denna metod nämner Weiss i boken på sida 409. 
			for (int i=0; i<strip.size(); i++) 
				for (int j=i+1; j< strip.size(); j++) 
					if ((strip.get(j).y - strip.get(i).y) > smallest) 
						break; 
					else 
					{ 
						double tmp = getDistance(strip.get(i), strip.get(j));
						if(tmp < smallest)
							smallest = tmp;
					} 
			return smallest;
		}
	}

	/**
	 * Brute force algoritm för basecase och testning av algoritmen.
	 * @param instervalStart
	 * @param intervalEnd
	 * @return delta som är det minsta avståndet mellan de närmaste punkterna. 
	 */
	public double findClosestInInterval(int intervalStart, int intervalEnd){
		double delta=Double.MAX_VALUE;
		for(int i=intervalStart; i<intervalEnd+1; i++){
			Point tmp = plane.get(i);
			for(int j = i+1; j<intervalEnd+1; j++ ){
				double newDelta=getDistance(tmp, plane.get(j));
				if(newDelta<delta){
					delta=newDelta;
				}
			}
		}
		return delta;
	}
}

\end{lstlisting}

\section{Poolfrågor}
Denna veckas fråga måste behandla giriga algoritmer.
\subsection{Fråga 1}
Förklara vad en girig algoritm är och ge ett par exempel på giriga algoritmer som vi har gått igenom under kursen. 
För ett högre betyg ska du förklara varför giriga algoritmer i vissa fall kan göra felberäkningar. Motivera ditt svar med exempel.
%\lstinputlisting[firstline=3, lastline=5]{SimpleLinkedList.java}

% Nedanstående är bara för om ni vill använda bibtex för att hantera referenser. 

%\bibliographystyle{plain}
%\bibliography{bibtex}
%\bibdata{bibtex}


\end{document}
