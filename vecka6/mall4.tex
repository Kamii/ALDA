% Alla i gruppen ska lämna in individuellt i Moodle. 
% Det ska dock vara samma fil för alla så att vi kan se vilka som har jobbat ihop.
\documentclass[a4paper,10pt,oneside,onecolumn]{article}

\usepackage[swedish]{babel}

% Får ni problem med att pdf-filen ser suddig ut på skärmen så beror det på att ni inte har 
% en fullständig fontuppsättning och att bitmappade fonter i fel skala används. Den bästa lösningen 
% är att uppdatera fontuppsättningen, men man kan också plocka bort denna rad. Avstavning fungerar 
% dock betydligt sämre då.
\usepackage[T1]{fontenc}

\usepackage[latin1]{inputenc}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{url}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{color}
\usepackage{hyperref}
\hypersetup{linktocpage}
\usepackage{xspace,graphicx}

\definecolor{javared}{rgb}{0.6,0,0} % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{javapurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc

\lstset{language=Java,
basicstyle=\ttfamily,
keywordstyle=\color{javapurple}\bfseries,
stringstyle=\color{javared},
commentstyle=\color{javagreen},
morecomment=[s][\color{javadocblue}]{/**}{*/},
numbers=left,
numberstyle=\small\color{black},
stepnumber=1,
numbersep=10pt,
tabsize=2,
showspaces=false,
showstringspaces=false,
breaklines=true}

% Glöm inte att uppdatera rubriken
\title{ALDA VT12:Sortering}

\author{Leon Hennings\\leonh \and Kamyar Sajjadi\\kamy-saj}

\begin{document}

\maketitle
\tableofcontents
\newpage


\section{MergeSorter}
\begin{lstlisting}
public class MergeSorter<T extends Comparable<? super T>> extends Sorter<T> {

  @Override
  protected void doSort(List<T> list) 
  {
    mergeSort(list);
  }

  /**
   * Internal method for having fun
   * @param list an array of Comparable items.
   */
  @SuppressWarnings("unchecked")
  private void mergeSort(List<T> list)
  {
    T[] tmpArray = (T[]) new Comparable[list.size()];

    mergeSort(list, tmpArray, 0, list.size() - 1 );
  }

  /**
   * Internal method that makes recursive calls.
   * @param list an array of Comparable items.
   * @param tmpArray an array to place the merged result.
   * @param left the left-most index of the subarray.
   * @param right the right-most index of the subarray.
   */
  private void mergeSort(List<T> list, T[] tmpArray, int left, int right )
  {
    if(left < right)
    {
      int center = ( left + right ) / 2;
      mergeSort(list, tmpArray, left, center );
      mergeSort(list, tmpArray, center + 1, right );
      merge(list, tmpArray, left, center + 1, right );
    }
  }

 /**
  * Internal method that merges two sorted halves of a subarray.
  * @param List an array of Comparable items.
  * @param tmpArray an array to place the merged result.
  * @param leftPos the left-most index of the subarray.
  * @param rightPos the index of the start of the second half.
  * @param rightEnd the right-most index of the subarray.
  *
  * Det vi har ändrat här är att metoderna tar List<T> som argument
  * och så har vi ändrat så get() används istället för indexparanterser
  */
 private void merge(List<T> list, T[] tmpArray, int leftPos, int rightPos, int rightEnd )
 {
   int leftEnd = rightPos - 1;
   int tmpPos = leftPos;
   int numElements = rightEnd - leftPos + 1;

   // Main loop
   while(leftPos <= leftEnd && rightPos <= rightEnd)
     if(list.get(leftPos).compareTo(list.get(rightPos)) <= 0)
       tmpArray[tmpPos++] = list.get(leftPos++);
     else
       tmpArray[tmpPos++] = list.get(rightPos++);

   while(leftPos <= leftEnd)    // Copy rest of first half
     tmpArray[ tmpPos++ ] = list.get(leftPos++);

   while( rightPos <= rightEnd )  // Copy rest of right half
     tmpArray[ tmpPos++ ] = list.get(rightPos++);

   // Copy tmpArray back
   for( int i = 0; i < numElements; i++, rightEnd-- )
     list.set(rightEnd, tmpArray[rightEnd]);
 }
}
\end{lstlisting}
\newpage

\section{QuickSorterFirstElement}
\begin{lstlisting}
public class QuickSorterFirstElement<T extends Comparable<? super T>> extends Sorter<T> {

  private static final int CUTOFF = 10;

  private void insertionSort(List<T> l, int left, int right) {
    int j;
    for (int p = left + 1; p <= right; p++) {
      T tmp = l.get(p);
      for (j = p; j > left && tmp.compareTo(l.get(j - 1)) < 0; j--) {
        l.set(j, l.get(j - 1));
      }
      l.set(j, tmp);
    }
  }

  /**
   * Internal method for the sorting. 
   * @param list The list that we want to sort.
   * @param left the left-most index of the subarray.
   * @param right the right-most index of the subarray.
   */
  private void quicksort(List<T> l, int left, int right) {
    if (left + CUTOFF <= right) {
      T pivot = firstElement(l, left, right);

      //Ändrat lite på index jämfört med 
      //orginalkoden (QuickSorterMedianThree)
      int i = left-1;
      int j = right+1;

      for (;;) {
        while (l.get(++i).compareTo(pivot) < 0) {
        }
        while (l.get(--j).compareTo(pivot) > 0) {
        }
        if (i < j)
          swap(l, i, j);
        else
          break;
      }

      swap(l, i, right); // restore pivot

      quicksort(l, left, i-1); // sort small elements
      quicksort(l, i, right); // sort large elements
    } else 
    {
      insertionSort(l, left, right);                                                              
    }
  }

  /**
   *  Method to pick the pivot. 
   *  returns the first element in List l from interval 
   *  left to right and swaps it to the last place. 
   *  @return T
   */
  private T firstElement(List<T> l, int left, int right) 
  {
    T first = l.get(left);
    swap(l, left, right);
    return first;  
  }

  @Override
  protected void doSort(List<T> l) 
  {
    quicksort(l, 0, l.size() - 1);
  }
}                                                                     

\end{lstlisting}
\newpage

\section{QuickSorterRandom}
\begin{lstlisting}
public class QuickSorterRandom<T extends Comparable<? super T>> extends Sorter<T> {
                                                                                         
  private static final int CUTOFF = 10;

  private void insertionSort(List<T> l, int left, int right) {
    int j;
    for (int p = left + 1; p <= right; p++) {
      T tmp = l.get(p);
      for (j = p; j > left && tmp.compareTo(l.get(j - 1)) < 0; j--) {
        l.set(j, l.get(j - 1));
      }
      l.set(j, tmp);
    }
  }

  /**
   * Internal method for the sorting. 
   * @param list The list that we want to sort.
   * @param left the left-most index of the subarray.
   * @param right the right-most index of the subarray.
   */
  private void quicksort(List<T> l, int left, int right) 
  {
    if (left + CUTOFF <= right) {
      T pivot = random(l, left, right);

      int i = left-1;
      int j = right+1;

      for (;;) {
        while (l.get(++i).compareTo(pivot) < 0) {
        }
        while (l.get(--j).compareTo(pivot) > 0) {
        }
        if (i < j)
          swap(l, i, j);
        else
          break;
      }

      swap(l, i, right); // restore pivot

      quicksort(l, left, i-1); // sort small elements
      quicksort(l, i, right); // sort large elements
    } else 
    {
      insertionSort(l, left, right);
    }
  }

  /**
   *  Method to pick the pivot. 
   *  returns a random placed T from the List i the interval
   *  left to right and swaps it to the last place. 
   *  @return T
   */
  private T random(List<T> l, int left, int right) 
  {
    Random rnd = new Random();
    int pivoNr = rnd.nextInt(right - left + 1)+left;
    swap(l, pivoNr, right);
    return l.get(right);
  }

  @Override
  protected void doSort(List<T> l) 
  {
    quicksort(l, 0, l.size() - 1);
  }
}                                                          
\end{lstlisting}
\newpage

\section{Analys av sorteringalgoritmer}
%Mergesort
Mergesort är en sorteringsalgortim som rekursivt bryter upp det som ska sorteras till mindre listor och sedan sorteras de mindre listorna. 
Därefter kommer dessa sättas samman och skapa en lista som är sorterad. 
Innan vi börjat köra våra testfall så diskutera vi vad vi trodde skulle ta längst tid att sortera, en arraylist eller en linkedlist. 
Vi kom ganska snabbt fram till att en länkadlista skulle ta längre tid att sortera än den förstnämnda. Enligt teorin är mergesort 
en algoritm som ska ta O(N log N). 
Tillskillnad från quicksort som är en in-place algoritm använder sig Mergesort av mer minne när den jobbar med komplexa datatyper. 
Detta då den behöver skapa en extra datastruktur som tar upp mer plats i minnet. 

%Quicksort med Random pivot
Quicksort väljer ut ett element som blir vridpunkten (pivot) och placerar detta i slutet av listan, i det här fallet väljs element 
slumpmässigt. Vridpunkten kan väljas ut på olika sätt. De olika sätt vi har implementerat valet av vridpunkten är med hjälp av en 
randomgenerator som väljer ut ett index ur listan och sätter pivot till det element som ligger på det indexet. Den andra versionen 
vi implementerat går ut på att vi väljer ut det första värdet som ligger i listan och använder det som vridpunkt. Sedan finns det 
ytterligare ett sätt att välja privovärdet som går ut på att räkna fram medianen av det första, sista och det elementet i mitten. 
I quicksort så söks listan igenom från vänster efter element som är större än vridpunkten och sedan från höger i jakt på element 
som är mindre än vridpunkten. När två element som uppfyller detta hittats byter de plats.
Detta fortsätter tills jämförelsepekaren som började från höger(j) är på ett lägre index än den som började från vänster(i), då 
byts vridpunkten mot det element som i pekar på.
Därefter kallas quicksort rekursivt på elementen till höger och de till vänster om vridpunkten.
Det är vanligt att använda sig av en annan sorteringsalgoritm för små sublistor och i det här fallet används insertionsort. 
Detta för att på mindre datamängder är simpla sorteringsalgoritmer mer effektiva. Detta fungerar som basecase för rekursionen. 

%Insertionsort
Insertionsort är en enkel sorteringsalgoritm. Oftast använder sig andra mer avancerade sorteringsalgoritmer sig av denna sortering som 
basecase, tex som vi nämnde ovan quicksort. Algoritmen är relativt snabb att använda för att sortera små datastrukturer. Det absolut 
bästa fallet för insertionsort är när det som ska sorteras redan är sorterat. Då kommer algoritmen ha en tidskomplexitet på O(N). 
Även när listan är relativt sorterad så kommer insertionsort att utföras snabbt. 
Själva implementationen består av en yttre loop som börjar på det andra elementet i listan och för varje iteration av den yttre 
loopen jämförs det med alla tidigare element tills något större hittas varpå elementen byter plats. I värsta fall, t ex om hela 
listan är sorterad i omvänd ordning, tar insertionsort O($N^{2}$) tid. 

%Selectionsort
Selectionsort är likt insertionsort en O($N^{2}$) sorteringsalgoritm. Selectionsort hittar det minsta värdet och byter plats med det värdet i 
första indexet. Sedan så går den vidare till nästa index och hittar det näst största värdet och byter plats. Detta görs med hela listan tills 
listan är helt sorterad. Implementationen som Henrik har bifogat ser ut på följande sätt. Den yttre loopen börjar på första elementet, på 
index x, och kopierar det till ett temporärt element. 
För varje varv söker den igenom hela resten av listan efter det minsta värdet och placerar det på platsen x varpå det temporära 
elementet tar det minsta elementets tidigare plats.
Sedan fortsätter yttre loopen på nästa plats i listan och inre loopen söker efter det näst lägsta värdet, och så vidare till listans slut nås. 
Selectionsort är som insertionsort snabb på att sortera små listor. Det som skiljer sig är att selectionsort alltid är O($N^{2}$) 
tillskillnad från insertionssort som i bästa fall är O(N).

\newpage
\section{Poolfråga}
\subsection{Fråga 1}
Quicksort och mergesort är två vanliga sorteringsalgoritmer som båda har genomsnittliga tidskomplexiteten O(n log n). 
Ge exempel på fall då den ena är att föredra över den andra. För högre betyg ska du även kunna säga varför med hänsyn 
till hur de är implementerade.

\subsection{Fråga 2}
Vissa sorteringsalgoritmer innehåller ofta en implementation av en annan sorteringsalgoritm. Ge två exempel på sådana 
sorteringsalgoritmer. För högre betyg ska du även förklara varför och i vilket skede av sorteringen som de andra sorteringsalgoritmerna 
används och ge exempel på algoritmer som vanligen används i detta syfte.

\subsection{Fråga 3}
Ge ett exempel på ett fall då de enkla sorteringsalgoritmerna insertionsort och bubblesort är att föredra över quicksort, även för listor 
av större storlek. För högre betyg ska du kunna visa på en liten lista med ca 10 element hur de skulle sorteras med de olika 
sorteringsalgoritmerna samt hur stor skillnaden på antal operationer som görs blir.


%\lstinputlisting[firstline=3, lastline=5]{SimpleLinkedList.java}

% Nedanstående är bara för om ni vill använda bibtex för att hantera referenser. 

%\bibliographystyle{plain}
%\bibliography{bibtex}
%\bibdata{bibtex}


\end{document}
