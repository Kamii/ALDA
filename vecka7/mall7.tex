% Alla i gruppen ska lämna in individuellt i Moodle. 
% Det ska dock vara samma fil för alla så att vi kan se vilka som har jobbat ihop.
\documentclass[a4paper,10pt,oneside,onecolumn]{article}

\usepackage[swedish]{babel}

% Får ni problem med att pdf-filen ser suddig ut på skärmen så beror det på att ni inte har 
% en fullständig fontuppsättning och att bitmappade fonter i fel skala används. Den bästa lösningen 
% är att uppdatera fontuppsättningen, men man kan också plocka bort denna rad. Avstavning fungerar 
% dock betydligt sämre då.
\usepackage[T1]{fontenc}

\usepackage[latin1]{inputenc}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{url}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{color}
\usepackage{hyperref}
\hypersetup{linktocpage}
\usepackage{xspace,graphicx}

\definecolor{javared}{rgb}{0.6,0,0} % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{javapurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc

\lstset{language=Java,
basicstyle=\ttfamily,
keywordstyle=\color{javapurple}\bfseries,
stringstyle=\color{javared},
commentstyle=\color{javagreen},
morecomment=[s][\color{javadocblue}]{/**}{*/},
numbers=left,
numberstyle=\small\color{black},
stepnumber=1,
numbersep=10pt,
tabsize=2,
showspaces=false,
showstringspaces=false,
breaklines=true}

% Glöm inte att uppdatera rubriken
\title{ALDA VT12: Grafer}

\author{Leon Hennings\\leonh \and Kamyar Sajjadi\\kamy-saj}

\begin{document}

\maketitle
\tableofcontents
\paragraph{}
Koden finns att ladda ner på \url{http://people.dsv.su.se/~kamy-saj/download/ALDA/}

Detta för att det ska bli lättare för er att göra en peer-review i er favorit editor. 

\begin{center}
Koden till zip-filen är: \textbf{rwa5uy3}
\end{center}
\newpage
\newpage

\section{Motivering till implemenetation}
Vi valde att göra vår graf som en adjacency list då vi i detta fallet inte skulle ha så många bågar mellan noderna i grafen.
Vi drog denna slutsats från testkoden och även från att det generellt inte finns så många kopplingar mellan noder i en genomsnittlig graf.
Då Kruskals algoritm är mer beroende av antalet bågar än hur stort trädet är så är den mer lämplig för uppgiften. Den är O(E log E) där E är antalet bågar.
Det är viktigt att alltid ta hänsyn till hur grafen kommer att användas. Hade vi haft många bågar mellan noderna i grafen hade det varit mer lönsamt 
ddatt använda sig av prims algoritm.
Eftersom vi skulle ha viktade bågar skapade vi en egen klass för dem. För att kruskals algoritm enkelt skulle kunna ta den lägst 
viktade bågen gjorde vi dessa comparable så de kunde ordnas i en prioritetskö.
För sammanslagningen av träd i algoritmen valde vi att använda depth-first search för att kontrollera så två noder inte befinner 
sig i samma träd. Alternativet hade varit att göra de mindre träden till set och göra merge på dessa då noder i de olika träden ska 
sammankopplas. Detta kräver flera datastrukturer för de olika träden. Då vi inte skulle hantera särskilt stora grafer kändes depth-first search fullt tillräckligt.
Se kommentarer i koden för mer ingående beskrivning av algoritmen.

\section{MyGraph}
\subsection{Privata variabler samt Edge klassen}
\begin{lstlisting}
public class MyGraph<T extends Comparable<? super T>> implements MiniGraph<T> 
{
	private HashSet<T> nodes = new HashSet<T>(); 
	private ArrayList<Edge<T>> edges= new ArrayList<Edge<T>>();

	/**
	 * The Edge class. 
	 * this class is pretty straightforward.
	 */
	private static class Edge<T> implements Comparable<Edge<T>>
	{
		private T node1;
		private T node2;
		private int weight;

		/**
		 * Constructor
		 * @param n1 One of the nodes
		 * @param n2 The other node ^^
		 * @param w weight of the edge
		 */
		public Edge(T n1, T n2, int w){
			node1 = n1;    
			node2 = n2;    
			weight = w;
		}

		/**
		 * GetMethod for weight
		 * @return int weight
		 */
		public int getW(){
			return weight;
		}

		/**
		 * GetMethod for node1
		 * @return T node1
		 */
		public T getN1(){
			return node1;
		}

		/**
		 * GetMethod for node2
		 * @return T node2
		 */
		public T getN2(){
			return node2;
		}

		/**
		 * A basic compareTo method 
		 * this method is comparing the weight of the edges
		 * @return int 
		 */
		public int compareTo(Edge other){
			if(other.weight < weight)
				return 1;
			else if (other.weight < weight)
				return -1;
			else
				return 0;
		}

		/**
		 * toString
		 * @return String 
		 */
		public String toString()
		{
			return node1+" "+ node2+" Weight: "+weight;
		}
	}
\end{lstlisting}
\newpage

\subsection{addNode}
\begin{lstlisting}
 	/**
	 * Method for adding a node to the graph. Silently ignores any duplicates
	 * @param n The node to add to the graph.
	 */
	public void addNode(T n)
	{
		nodes.add(n);
	}
\end{lstlisting}

\subsection{connectNodes}
\begin{lstlisting}
 	/**
	 * Method for creating an unidirectional edge between two nodes. Does
	 * nothing if the cost is negative, the edges are already connected, or if
	 * one or more of the nodes doesn't exists.
	 * @param n1 The first node to create an edge between
	 * @param n2 The second node to create an edge between
	 * @param weight The cost for traversing the edge
	 */
	public void connectNodes(T n1, T n2, int weight)
	{
		if(!(weight<0))
			if(nodes.contains(n1) && nodes.contains(n2))
				if(!edgeExistsBetween(n1, n2))
				{
					Edge<T> e = new Edge<T>(n1, n2, weight);
					edges.add(e);
				}
	}
\end{lstlisting}

\subsection{contains}
\begin{lstlisting}

 	/**
	 * Method for searching the graph for a certain node. If the node is present
	 * in the graph, the method returns true, otherwise, it returns false.
	 * 
	 * @return boolean true if the graph contains n, otherwise false.
	 */
	public boolean contains(T n){
		return nodes.contains(n);
	}
\end{lstlisting}
\newpage

\subsection{getNumberOfNodes}
\begin{lstlisting}
 	/**
	 * Method for finding the number of nodes in the graph.
	 * 
	 * @returns int The number of nodes in the graph.
	 */
	public int getNumberOfNodes(){
		return nodes.size();
	}
\end{lstlisting}

\subsection{edgeExistsBetween}
\begin{lstlisting}
 	/**
	 * Checks if there exists and edge between nodes n1 and n2. Used for testing
	 * purposes.
	 * 
	 * @param n1 The first node that identifies the edge.
	 * @param n2 The second node that identifies the edge.
	 * @return true if and edge exists between n1 and n2, otherwise false.
	 */
	public boolean edgeExistsBetween(T n1, T n2){
		for(Edge e : edges){
			if(e.node1 == n1 && e.node2 == n2
					|| e.node1 == n2 && e.node2 == n1)
				return true;
		}
		return false;
	}
\end{lstlisting}

\subsection{getNumberOfEdges}
\begin{lstlisting}
 	/**
	 * Gets the number of edges in the graph. Used for testing purposes.
	 * 
	 * @return the number of edges in the graph.
	 */
	public int getNumberOfEdges(){
		return edges.size();
	}
\end{lstlisting}
\newpage

\subsection{getTotalEdgeWeight}
\begin{lstlisting}
 	/**
	 * Gets the total weight of all edges. Used for testing purposes.
	 * 
	 * @return the total weight of all the edges
	 */
	public int getTotalEdgeWeight(){
		int total = 0;
		for(Edge e : edges){
			total += e.weight;
		}
		return total;
	}
\end{lstlisting}

\subsection{generateMinimumSpanningTree}
\begin{lstlisting}

 /**
	 * Method for calculating a minimum spanning tree for the graph. 
	 * This method is generating the minimum spanning tree. We are using kruskals 
	 * algoritm. 
	 *
	 * @return tree Graph A new instance of the Graph class, representing a minimal
	 * spanning tree. 
	 */
	public MyGraph<T> generateMinimumSpanningTree(){
		// grafen som ska returneras
		MyGraph<T> tree = new MyGraph<T>();
		// bågarna sorterade efter minst först
		PriorityQueue<Edge> deck = new PriorityQueue<Edge>(edges);

		while((getNumberOfNodes()-1) > tree.getNumberOfEdges())              
		{
			Edge<T> tmp = deck.poll();

			// Om ingen av noderna finns med i tree så lägger vi till noderna i tree och 
			// kopplar dessa. Notera att addAndConnectToMinimumSpanningTree har en 
			// kontroll så att det i inte redan finns en kopling mellan noderna. I detta 
			// fall behövs det då en nod som är kopplad till sig själv ej ska läggas till. 
			if( (!tree.nodes.contains(tmp.getN1()) || !tree.nodes.contains(tmp.getN2()) )) 
			{
				addAndConnectToMinimumSpanningTree(tmp, tree);
			}

			// Annars om noderna redan finns med i vårat träd så ska vi eventuellt slå 
			// ihop träden till ett större träd. Även här är det viktigt med kontrollen 
			// som ligger i addAndConnectToMinimumSpanningTree detta för att inte bågen 
			// ska läggas till om de ligger i samma träd. Om kontrollen ej hade varit med
			// skulle det kunna uppstå cykler. 
			else if(tree.nodes.contains(tmp.getN1()) && tree.nodes.contains(tmp.getN2()))
			{
				addAndConnectToMinimumSpanningTree(tmp,tree);
			}
		}
		return tree;
	}
\end{lstlisting}

\subsection{addAndConnectToMinimumSpanningTree}
\begin{lstlisting}
 	/**
	 * Internal method for adding nodes and connect them. 
	 * Sorry for the long method name. 
	 * @param tmp the edge with all info that we need to use. 
	 * @param tree the forest we are building. 
	 */
	private void addAndConnectToMinimumSpanningTree(Edge<T> tmp, MyGraph<T> tree)
	{
		if(!tree.depthFirstSearch(tmp.getN1(), tmp.getN2()))
		{
			tree.addNode(tmp.getN1());
			tree.addNode(tmp.getN2());
			tree.connectNodes(tmp.getN1(), tmp.getN2(), tmp.getW());
		}
	}

\end{lstlisting}

\subsection{depthFirstSearch boolean}
\begin{lstlisting}
 	/**
	 * Depth-first search method.
	 * This method will return true if it finds a
	 * path between from-node and to-node
	 * @param from from-node
	 * @param to to-node
	 */
	private boolean depthFirstSearch(T from, T to)
	{
		Set<T> visited = new HashSet<T>();
		depthFirstSearch(from, visited);
		return visited.contains(to);
	}
\end{lstlisting}
\newpage

\subsection{depthFirstSearch void}
\begin{lstlisting}
 	/**
	 * Internal method for depthFirstSearch(T, T).
	 * Building the HashSet with rekursion. 
	 * @param T from-node
	 * @param visited the hashset
	 */
	private void depthFirstSearch(T from, Set<T> visited)
	{
		visited.add(from);

		for(Edge<T> e : edges)
		{
			T tmp = null;

			// Kollar om någon av noderna är den noden som vi ska utgå från.
			// sedan sätter den destinationsnoden till tmp och gör ett rekursivt 
			// anrop.
			if(e.getN1().equals(from) || e.getN2().equals(from))
				tmp = e.getN1().equals(from) ? e.getN2(): e.getN1();

			if(!visited.contains(tmp))
				depthFirstSearch(tmp, visited);
		}
	}
\end{lstlisting}
\newpage

\section{Grafalgoritmer}
\subsection{Multigrafer}
\subsubsection{Prims algoritm}
Algoritmen fungerar för multigrafer utan modifikationer så länge de är oriktade. För riktade grafer är det irrelevant då ett 
riktat träd inte kan vara spanning.
Anledningen till att det fungerar även för multigrafer är att bågarnas vikt alltid jämförs och det minsta kommer väljas oavsett 
om det finns flera bågar mellan ett par noder.
\subsubsection{Kruskals algoritm}
Då Kruskals algoritm endast tar de kortaste bågarna för alla noder som inte redan är ihopkopplade kommer det inte spela 
någon roll ifall grafen är en multigraf. 
\subsubsection{Dijkstras algoritm}
Denna algoritm kommer att fungera på multigrafer. Dijkstras kommer alltid att hitta den kortaste vägen från X till Y även 
om det finns fler bågar ut från en nod till en annan. Det man eventuellt ska ta hänsyn till när dijkstras används på multigrafer 
är att hålla reda på vilken av bågarna som var den kortaste vägen. Så om det finns två bågar ut från A till B så måste vi ta 
hänsyn till vilken av dessa två bågar som har den lägsta vikten och spara denna i tabellen. Sedan bör de bågar returneras som 
leder till slutnoden istället som i vanliga fall då noderna som bildar den kortaste vägen returneras.
\subsubsection{Djupet först sökning}
Djupet först-sökning fungerar för multigrafer. Den kommer se om det finns en koppling mellan X och Y. Man kan tro att samma 
nod kommer besökas fler gånger om det finns fler bågar ut till samma nod, men eftersom algoritmen markerar noderna när den har 
besökt dem så kommer vi inte behöva gå till samma nod fler gånger. 
\subsubsection{Bredden först sökning}
På samma sätt som djupet först sökning kommer bredden först sökning fungera för multigrafer. Eftersom vilka noder som besökts 
och deras lägsta vikt sparas undan kommer de fallen där noder har flera bågar inte spela någon roll mer än ur effektivitets perspektiv.
\subsubsection{Topologisk sortering}
Kommer ej att fungera på grafen om den inte är riktad. Om multigrafen är riktad så kommer denna algoritm att fungera. Algoritmen 
kollar på den nod som är minimal, dvs den nod som ej har några bågar inåt. Algoritmen tar ej hänsyn till hur många bågar som går 
utåt från den minimala noden. Därav kommer topologisk sortering att fungera på multigrafer.
\newpage
\subsection{Negativ vikt}
\subsubsection{Prims algoritm}
För grafer med negativa vikter fungerar denna algoritm. Det påverkar inte algoritmen att bågarna har negativa vikter. Algoritmen 
kommer ta den minsta bågen till nästa nod, men endast om den ej har besökt den noden. Detta gör att det ej spelar någon roll om 
det är ett negativt tal eller positivt, så länge det är det minsta talet av alla de som finns att välja på. Tabellen som byggs 
upp i algoritmen består av de lägsta noderna som sammansätter grafen till ett träd, det vill säga att det inte påverkar om det är negativa tal. 

\subsubsection{Kruskals algoritm}
Även denna algoritm fungerar med negativt viktade grafer. Kruskals algoritm bygger trädet med hjälp av de bågar som har lägst 
värde. Detta innebär att det inte spelar någon roll om bågarna har negativa värden, så länge det är de bågar med lägst vikt som används för att bygga trädet. 
\subsubsection{Dijkstras algoritm}
Dijkstras algoritm kommer ej att fungera på denna sortens grafer. Algoritmen går ut på att man räknar kostnaden hittills från nod A till B.
Det innebär att man, ifall grafen är riktad, kan gå tillbaka till en redan besökt nod och på så vis använda den negativa vikten 
för att minska totalvikten ett oändligt antal gånger för att försöka få fram den kortaste vägen.
En lösning för detta problem skulle vara att alltid se till så att samtliga bågar i grafen blir positiva. Detta genom att addera 
lägsta vikten med ett tills den blir positiv och sedan addera lika mycket till de andra vikterna, så att alla blir positiva men 
differensen är bevarad sinsemellan. Det viktiga här är att bågarnas vikt i förhållande till varandra ej ändras. 
\subsubsection{Djupet först sökning}
Djupet först-sökning tar inte hänsyn till bågarnas vikt i sin sökning. Negativ vikt har därför ingen verkan på dess funktionalitet. Den kommer endast att hitta
en väg mellan noderna, om noderna är negativa eller inte har ingen betydelse. 
\subsubsection{Bredden först sökning}
Den följer alla bågar tills rätt nod hittas utan hänsyn till bågarnas vikt och fungerar därför för negativa vikter av samma anledning som djupet-först-sökning.
\subsubsection{Topologisk sortering}
Topologisk sortering kommer att fungera med negativt viktade grafer. Sorteringen tar ej hänsyn till vikterna på bågarna. Den kommer endast att leta efter
den lägsta noden. Lägsta i topologisk sortering innebär den noden som ej har några bågar in mot sig. 

\newpage
\section{Poolfrågor}
2. Frågan måste behandla hur grafer kan implementeras.
\subsection{Fråga 1}
Förklara skillnaden på adjacency list och adjacency matrix, ge exempel på när de är att föredra.
För högre betyg ska du även förklara vad som krävs för att båda varianterna ska kunna hantera viktade kanter.
\subsection{Fråga 2}
Givet en fullständig graf (alla noder har bågar till alla andra noder) vilket sätt är mest lönsamt att implementera 
denna på och vilken algoritm är bäst lämpad för att bestämma det minimalt spännande trädet i grafen? 
För högre betyg ska du motivera ditt val av implemenetation och algoritm på ett sätt som visar att du förstått dem båda.
%\lstinputlisting[firstline=3, lastline=5]{SimpleLinkedList.java}

% Nedanstående är bara för om ni vill använda bibtex för att hantera referenser. 

%\bibliographystyle{plain}
%\bibliography{bibtex}
%\bibdata{bibtex}


\end{document}
